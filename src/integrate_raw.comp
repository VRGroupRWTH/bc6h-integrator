#version 450 core
#extension GL_GOOGLE_include_directive : require

#define DATA_RAW_TEXTURES 
#include "integration.glsl"

void main()
{
    if (any(greaterThanEqual(gl_GlobalInvocationID, constants.seed_dimensions))) {
        return;
    }

    const uint seed_id =
        gl_GlobalInvocationID.x +
        gl_GlobalInvocationID.y * constants.seed_dimensions.x + 
        gl_GlobalInvocationID.z * constants.seed_dimensions.x * constants.seed_dimensions.y;
    const uint line_buffer_offset = seed_id * constants.total_step_count + constants.first_step;

    vec3 position;
    if (constants.first_step == 0) {
        const vec3 relative_seed_position = vec3(gl_GlobalInvocationID) / constants.seed_dimensions;
        
        const vec3 initial_position =  vec3(constants.dataset_dimensions) * relative_seed_position; 
        vertices[line_buffer_offset] = vec4(initial_position, float(seed_id));

        indirect_draw[seed_id].vertex_count = 1;
        indirect_draw[seed_id].instance_count = 1;
        indirect_draw[seed_id].first_vertex = line_buffer_offset;
        indirect_draw[seed_id].first_instance = 0;

        position = initial_position;
    } else {
        position = vertices[seed_id * constants.total_step_count + indirect_draw[seed_id].vertex_count - 1].xyz;
    }

    float t = constants.first_step * constants.dt;
    for (uint s = constants.first_step == 0 ? 1 : 0; s < constants.step_count; ++s) {
        const vec4 sample_location = vec4(position, t);
        
        if (any(lessThan(sample_location, vec4(0))) || any(greaterThan(sample_location, constants.dataset_dimensions))) {
            atomicAdd(progress, constants.step_count - s);
            break;
        }

        const vec3 next_position = position + constants.dt * rungekutta4(sample_location);
        vertices[line_buffer_offset + s] = vec4(next_position, seed_id);
        position = next_position;
        t += constants.dt;

        atomicAdd(indirect_draw[seed_id].vertex_count, 1);
        atomicAdd(progress, 1);
    }
}
